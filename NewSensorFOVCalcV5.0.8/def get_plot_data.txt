def get_plot_data(params, x_range_mm=(-350, 350), y_range_mm=(-350, 350), n_ticks=9, smoothness=2, smoothing_window=1):
    """Return plotting data instead of a figure - prevents flickering"""
    A = params['A']
    B = params['B']
    C = params['C']
    theta_deg = params['Tilt']
    margin_percent = params['Margin']
    try:
        margin_percent = float(margin_percent)
    except Exception:
        margin_percent = 0.0
    shift = params['Shift']
    shift_axis = params['ShiftAxis']
    resolution = params['Resolution']
    
    margin_factor = 1.0 + (margin_percent / 100.0)
    H = A
    L = B * margin_factor
    W = C * margin_factor
    theta = np.deg2rad(theta_deg)

    # Camera position based on shift axis
    if shift_axis == 'X':
        Xc = W / 2 + shift
        Yc = 0
    else:  # Y-axis
        Xc = 0
        Yc = L / 2 + shift
    cam_pos = np.array([Xc, Yc, H])

    # Camera optical axis determined by user's tilt angle
    initial_optical_axis = np.array([0, 0, -1])  # Straight down
    
    # Apply tilt rotation based on shift axis
    if shift_axis == 'X':
        Ry = np.array([
            [np.cos(theta), 0, np.sin(theta)],
            [0, 1, 0],
            [-np.sin(theta), 0, np.cos(theta)]
        ])
        z_cam = Ry @ initial_optical_axis
    else:  # Y-axis
        theta_corrected = -theta
        Rx = np.array([
            [1, 0, 0],
            [0, np.cos(theta_corrected), -np.sin(theta_corrected)],
            [0, np.sin(theta_corrected), np.cos(theta_corrected)]
        ])
        z_cam = Rx @ initial_optical_axis
    
    z_cam = z_cam / np.linalg.norm(z_cam)

    # Calculate OPTIMAL TILT ANGLE based on maximum water coverage
    optimal_angle, optimal_coverage = find_optimal_angle_for_coverage(params, smoothing_window=smoothing_window)

    # Calculate water coverage curve for plotting
    coverage_angles, coverage_values = calculate_water_coverage_curve(params, smoothing_window=smoothing_window)

    # Apply correct sign convention to optimal angle
    if shift_axis == 'X':
        optimal_angle_corrected = -optimal_angle if Xc > 0 else optimal_angle
    else:
        optimal_angle_corrected = -optimal_angle if Yc > 0 else optimal_angle

    # Camera basis vectors
    if abs(np.dot(z_cam, [0, 1, 0])) > 0.99:
        up_guess = np.array([1, 0, 0])
    else:
        up_guess = np.array([0, 1, 0])
    x_cam = np.cross(up_guess, z_cam)
    x_cam = x_cam / np.linalg.norm(x_cam)
    y_cam = np.cross(z_cam, x_cam)
    y_cam = y_cam / np.linalg.norm(y_cam)

    # Project a 3D point to the camera image plane
    def project_point(p_world):
        v = p_world - cam_pos
        Xc = np.dot(v, x_cam)
        Yc = np.dot(v, y_cam)
        Zc = np.dot(v, z_cam)
        if abs(Zc) < 1e-10:
            return np.array([0, 0])
        x_img = H * Xc / Zc
        y_img = H * Yc / Zc
        return np.array([x_img, y_img])

    # Calculate all the plotting elements
    rect_res = 100
    x_rect = np.linspace(-W/2, W/2, rect_res)
    y_rect = np.linspace(-L/2, L/2, rect_res)
    xx_rect, yy_rect = np.meshgrid(x_rect, y_rect)
    rect_points = np.column_stack([xx_rect.ravel(), yy_rect.ravel(), np.zeros(rect_res**2)])
    proj_rect_pts = np.array([project_point(p) for p in rect_points])

    # Ellipse outline
    ell_res = 200
    angles = np.linspace(0, 2*np.pi, ell_res)
    ell_x = (C/2) * np.cos(angles)
    ell_y = (L/2) * np.sin(angles)
    ellipse_points = np.column_stack([ell_x, ell_y, np.zeros(ell_res)])
    proj_ellipse_pts = np.array([project_point(p) for p in ellipse_points])

    # Rectangle corners
    rect_corners = np.array([
        [-W/2, -L/2, 0], [ W/2, -L/2, 0], [ W/2,  L/2, 0], [-W/2,  L/2, 0], [-W/2, -L/2, 0]
    ])
    proj_rect_outline = np.array([project_point(p) for p in rect_corners])

    # Water spot bounds for reference
    ellipse_min_x, ellipse_max_x = np.min(proj_ellipse_pts[:, 0]), np.max(proj_ellipse_pts[:, 0])
    ellipse_min_y, ellipse_max_y = np.min(proj_ellipse_pts[:, 1]), np.max(proj_ellipse_pts[:, 1])
    ellipse_cx = (ellipse_min_x + ellipse_max_x) / 2
    ellipse_cy = (ellipse_min_y + ellipse_max_y) / 2
    ellipse_half_width = (ellipse_max_x - ellipse_min_x) / 2
    ellipse_half_height = (ellipse_max_y - ellipse_min_y) / 2

    # Calculate required FOV with margin
    water_extent_from_optical_axis_x = max(abs(ellipse_min_x), abs(ellipse_max_x))
    water_extent_from_optical_axis_y = max(abs(ellipse_min_y), abs(ellipse_max_y))
    
    required_half_width = water_extent_from_optical_axis_x * (1 + margin_percent / 100)
    required_half_height = water_extent_from_optical_axis_y * (1 + margin_percent / 100)

    # REALISTIC SENSOR: Find smallest standard aspect ratio sensor that fits required FOV
    sensor_half_width, sensor_half_height, aspect_ratio_used = find_realistic_sensor_size(
        required_half_width, required_half_height)
    sensor_width_mm = 2 * sensor_half_width
    sensor_height_mm = 2 * sensor_half_height

    #px = int(np.ceil(sensor_width_mm / resolution))
    #py = int(np.ceil(sensor_height_mm / resolution))

    px = 50
    py = 50

    # FOV box coordinates - symmetrical around optical axis (0,0)
    box_x_mm = np.array([-sensor_half_width, sensor_half_width, sensor_half_width, 
                         -sensor_half_width, -sensor_half_width])
    box_y_mm = np.array([-sensor_half_height, -sensor_half_height, sensor_half_height, 
                         sensor_half_height, -sensor_half_height])

    enforce_ifov = params.get('EnforceIFOV', False)
    pixel_pitch_um = params.get("PixelPitch", 2.0)
    pixels_x = max(2, int(np.ceil(sensor_width_mm / resolution)))
    pixels_y = max(2, int(np.ceil(sensor_height_mm / resolution)))
    max_pixels = params.get('MaxSensorRes', 5000)
    px = min(px, max_pixels)
    py = min(py, max_pixels)

    if not enforce_ifov:
        pixels_x_sensor = int(pixels_x)
        pixels_y_sensor = int(pixels_y)
        max_ifov = resolution
    else:
        # Find projected IFOV at rim for naive pixel grid
        max_ifov = compute_max_projected_pixel_size(
            sensor_half_width, sensor_half_height, pixels_x, pixels_y,
            cam_pos, x_cam, y_cam, z_cam, H
        )
        ifov_factor = max(1.0, max_ifov / resolution)
        # Adjust pixel count to physically achievable level if needed
        new_pixels_x = int(np.ceil(pixels_x * ifov_factor))
        new_pixels_y = int(np.ceil(pixels_y * ifov_factor))
        # Enforce max pixel cap
        limit_factor = max(new_pixels_x / max_pixels, new_pixels_y / max_pixels, 1.0)
        if limit_factor > 1.0:
            new_pixels_x = min(new_pixels_x, max_pixels)
            new_pixels_y = min(new_pixels_y, max_pixels)
            max_ifov = resolution * limit_factor
        pixels_x_sensor = int(new_pixels_x)
        pixels_y_sensor = int(new_pixels_y)

    ellipse_width_with_margin = ellipse_half_width * 2 * (1 + margin_percent / 100)
    ellipse_height_with_margin = ellipse_half_height * 2 * (1 + margin_percent / 100)
    pixels_x_naive = round(ellipse_width_with_margin / resolution)
    pixels_y_naive = round(ellipse_height_with_margin / resolution)

    # Calculate minimum required pixels (no aspect ratio constraint) to meet target IFOV over full field
    target_sensor_width_mm = 2 * required_half_width
    target_sensor_height_mm = 2 * required_half_height

    # No aspect ratio constraint for target
    pixels_x_target = int(np.ceil(target_sensor_width_mm / resolution))
    pixels_y_target = int(np.ceil(target_sensor_height_mm / resolution))

    pixel_pitch_um = params.get('PixelPitch', 2.0)
    pixel_pitch_mm = pixel_pitch_um * 0.001
    # Compute physical size these pixels would actually span on the sensor
    target_sensor_width_mm = pixels_x_target * pixel_pitch_mm
    target_sensor_height_mm = pixels_y_target * pixel_pitch_mm
    # Calculate water coverage efficiency
    def calculate_water_coverage_efficiency():
        coverage_grid_size = 100
        sensor_x = np.linspace(-sensor_half_width, sensor_half_width, coverage_grid_size)
        sensor_y = np.linspace(-sensor_half_height, sensor_half_height, coverage_grid_size)
        sensor_xx, sensor_yy = np.meshgrid(sensor_x, sensor_y)
        
        water_pixels = 0
        total_pixels = coverage_grid_size * coverage_grid_size
        
        for i in range(coverage_grid_size):
            for j in range(coverage_grid_size):
                pixel_x = sensor_xx[i, j]
                pixel_y = sensor_yy[i, j]
                
                rel_x = pixel_x - ellipse_cx
                rel_y = pixel_y - ellipse_cy
                
                if (rel_x / ellipse_half_width)**2 + (rel_y / ellipse_half_height)**2 <= 1:
                    water_pixels += 1
        
        coverage_percentage = (water_pixels / total_pixels) * 100
        return coverage_percentage, water_pixels, total_pixels

    water_coverage_percent, water_pixels, total_sensor_pixels = calculate_water_coverage_efficiency()

    # Calculate naive values
    ellipse_width_with_margin = ellipse_half_width * 2 * (1 + margin_percent / 100)
    ellipse_height_with_margin = ellipse_half_height * 2 * (1 + margin_percent / 100)
    pixels_x_naive = int(np.ceil(ellipse_width_with_margin / resolution))
    pixels_y_naive = int(np.ceil(ellipse_height_with_margin / resolution))

    # Optics calculations
    all_x_coords = np.concatenate([box_x_mm, proj_ellipse_pts[:, 0]])
    all_y_coords = np.concatenate([box_y_mm, proj_ellipse_pts[:, 1]])
    dists = np.sqrt(all_x_coords**2 + all_y_coords**2)
    optics_radius = np.max(dists)
    optics_diameter = 2 * optics_radius

    # FOV points for world view
    fov_points_world = [
        [-C/2, -L/2, 0], [C/2, -L/2, 0], [C/2, L/2, 0], [-C/2, L/2, 0],
        [0, -L/2, 0], [0, L/2, 0], [-C/2, 0, 0], [C/2, 0, 0]
    ]

    # Side view calculations
    if shift_axis == 'X':
        side_cam_x = Xc
        side_cam_z = H
        optical_axis_2d = np.array([z_cam[0], z_cam[2]])
    else:
        side_cam_x = Yc
        side_cam_z = H
        optical_axis_2d = np.array([z_cam[1], z_cam[2]])

    camera_center_x = side_cam_x
    camera_center_z = side_cam_z
    
    sensor_normal_2d = optical_axis_2d / np.linalg.norm(optical_axis_2d)
    sensor_tangent_2d = np.array([-sensor_normal_2d[1], sensor_normal_2d[0]])
    optical_axis_normalized = optical_axis_2d / np.linalg.norm(optical_axis_2d)
    optimal_axis_2d = np.array([np.sin(np.radians(optimal_angle_corrected)), -np.cos(np.radians(optimal_angle_corrected))])

    print("DEBUG: ellipse_half_width", ellipse_half_width)
    print("DEBUG: ellipse_half_height", ellipse_half_height)
    print("DEBUG: required_half_width", required_half_width)
    print("DEBUG: required_half_height", required_half_height)
    print("DEBUG: sensor_half_width", sensor_half_width)
    print("DEBUG: sensor_half_height", sensor_half_height)
    print("DEBUG: sensor_width_mm", sensor_width_mm)
    print("DEBUG: sensor_height_mm", sensor_height_mm)

    ifov_map = None
    if params.get("EnforceIFOV", False):
        #px = int(np.ceil(2 * sensor_half_width / resolution))
        #py = int(np.ceil(2 * sensor_half_height / resolution))
        px = 100
        py = 100
        x_edges = np.linspace(-sensor_half_width, sensor_half_width, px + 1)
        y_edges = np.linspace(-sensor_half_height, sensor_half_height, py + 1)
        ifov_map = np.zeros((px, py))

        # Top 10 rows
        for j in range(min(10, py)):
            for i in range(px):
                corners = [
                    (x_edges[i], y_edges[j]),
                    (x_edges[i+1], y_edges[j]),
                    (x_edges[i+1], y_edges[j+1]),
                    (x_edges[i], y_edges[j+1])
                ]
                world_xy = []
                for x_s, y_s in corners:
                    ray = x_s * x_cam + y_s * y_cam + H * z_cam
                    ray = ray / np.linalg.norm(ray)
                    t = -cam_pos[2] / ray[2]
                    pt = cam_pos + t * ray
                    world_xy.append(pt[:2])
                world_xy = np.array(world_xy)
                edges = [np.linalg.norm(world_xy[k] - world_xy[(k+1)%4]) for k in range(4)]
                ifov_map[i, j] = max(edges)

            # Bottom 10 rows
            for j in range(max(py-10, 0), py):
                for i in range(px):
                    corners = [
                        (x_edges[i], y_edges[j]),
                        (x_edges[i+1], y_edges[j]),
                        (x_edges[i+1], y_edges[j+1]),
                        (x_edges[i], y_edges[j+1])
                    ]
                    world_xy = []
                    for x_s, y_s in corners:
                        ray = x_s * x_cam + y_s * y_cam + H * z_cam
                        ray = ray / np.linalg.norm(ray)
                        t = -cam_pos[2] / ray[2]
                        pt = cam_pos + t * ray
                        world_xy.append(pt[:2])
                    world_xy = np.array(world_xy)
                    edges = [np.linalg.norm(world_xy[k] - world_xy[(k+1)%4]) for k in range(4)]
                    ifov_map[i, j] = max(edges)

            # Leftmost 10 columns
            for i in range(min(10, px)):
                for j in range(py):
                    corners = [
                        (x_edges[i], y_edges[j]),
                        (x_edges[i+1], y_edges[j]),
                        (x_edges[i+1], y_edges[j+1]),
                        (x_edges[i], y_edges[j+1])
                    ]
                    world_xy = []
                    for x_s, y_s in corners:
                        ray = x_s * x_cam + y_s * y_cam + H * z_cam
                        ray = ray / np.linalg.norm(ray)
                        t = -cam_pos[2] / ray[2]
                        pt = cam_pos + t * ray
                        world_xy.append(pt[:2])
                    world_xy = np.array(world_xy)
                    edges = [np.linalg.norm(world_xy[k] - world_xy[(k+1)%4]) for k in range(4)]
                    ifov_map[i, j] = max(edges)

            # Rightmost 10 columns
            for i in range(max(px-10, 0), px):
                for j in range(py):
                    corners = [
                        (x_edges[i], y_edges[j]),
                        (x_edges[i+1], y_edges[j]),
                        (x_edges[i+1], y_edges[j+1]),
                        (x_edges[i], y_edges[j+1])
                    ]
                    world_xy = []
                    for x_s, y_s in corners:
                        ray = x_s * x_cam + y_s * y_cam + H * z_cam
                        ray = ray / np.linalg.norm(ray)
                        t = -cam_pos[2] / ray[2]
                        pt = cam_pos + t * ray
                        world_xy.append(pt[:2])
                    world_xy = np.array(world_xy)
                    edges = [np.linalg.norm(world_xy[k] - world_xy[(k+1)%4]) for k in range(4)]
                    ifov_map[i, j] = max(edges)

                

    # Return all data needed for plotting
    return {
    # Basic parameters
    'A': A, 'B': B, 'C': C, 'H': H, 'L': L, 'W': W,
    'theta_deg': theta_deg, 'shift_axis': shift_axis,
    'Xc': Xc, 'Yc': Yc,
    
    # Plotting arrays
    'rect_corners': rect_corners,
    'proj_rect_pts': proj_rect_pts,
    'proj_ellipse_pts': proj_ellipse_pts,
    'proj_rect_outline': proj_rect_outline,
    'box_x_mm': box_x_mm,
    'box_y_mm': box_y_mm,
    'fov_points_world': fov_points_world,
    
    # Ellipse data
    'ellipse_cx': ellipse_cx,
    'ellipse_cy': ellipse_cy,
    'ellipse_half_width': ellipse_half_width,
    'ellipse_half_height': ellipse_half_height,
    
    # Sensor data
    'aspect_ratio_used': aspect_ratio_used,
    'pixels_x_sensor': pixels_x_sensor,
    'pixels_y_sensor': pixels_y_sensor,
    'pixels_x_naive': pixels_x_naive,
    'pixels_y_naive': pixels_y_naive,
    'pixels_x_target': pixels_x_target,  # NEW
    'pixels_y_target': pixels_y_target,  # NEW
    'target_sensor_width_mm': target_sensor_width_mm,  # NEW
    'target_sensor_height_mm': target_sensor_height_mm,  # NEW
    'max_ifov': max_ifov,
    'water_coverage_percent': water_coverage_percent,
    
    # Optimal angle data
    'optimal_angle': optimal_angle,
    'optimal_coverage': optimal_coverage,
    'coverage_angles': coverage_angles,
    'coverage_values': coverage_values,
    
    # Optics data
    'optics_radius': optics_radius,
    'optics_diameter': optics_diameter,
    'projection_offset': np.sqrt(ellipse_cx**2 + ellipse_cy**2),
    
    # Side view data
    'camera_center_x': camera_center_x,
    'camera_center_z': camera_center_z,
    'sensor_tangent_2d': sensor_tangent_2d,
    'optical_axis_normalized': optical_axis_normalized,
    'optimal_axis_2d': optimal_axis_2d,

    'sensor_width_mm': sensor_width_mm,
    'sensor_height_mm': sensor_height_mm,

    'ifov_map': ifov_map,
    'px_sensor': px,
    'py_sensor': py
}